"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CallStack_1 = require("./CallStack");
const VariablesState_1 = require("./VariablesState");
const Value_1 = require("./Value");
const PushPop_1 = require("./PushPop");
const Tag_1 = require("./Tag");
const Glue_1 = require("./Glue");
const Path_1 = require("./Path");
const ControlCommand_1 = require("./ControlCommand");
const StoryException_1 = require("./StoryException");
const StringBuilder_1 = require("./StringBuilder");
const JsonSerialisation_1 = require("./JsonSerialisation");
const PRNG_1 = require("./PRNG");
const Void_1 = require("./Void");
const Pointer_1 = require("./Pointer");
const TryGetResult_1 = require("./TryGetResult");
const TypeAssertion_1 = require("./TypeAssertion");
const Debug_1 = require("./Debug");
const NullException_1 = require("./NullException");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this._currentTurnIndex = -1;
        let timeSeed = (new Date()).getTime();
        this.storySeed = (new PRNG_1.PRNG(timeSeed)).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        return JSON.stringify(this.jsonToken, null, (indented) ? 2 : 0);
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        this.jsonToken = JSON.parse(json);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut = TryGetResult_1.tryGetValueFromMap(this.visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException('pointer.path');
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = (c == ' ') || (c == '\t');
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != '\n' && currentWhitespaceStart > 0 && currentWhitespaceStart != startOfLine) {
                    sb.Append(' ');
                }
                currentWhitespaceStart = -1;
            }
            if (c == '\n')
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    Copy() {
        let copy = new StoryState(this.story);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        this.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy._variablesState = new VariablesState_1.VariablesState(copy.callStack, this.story.listDefinitions);
        copy.variablesState.CopyFrom(this.variablesState);
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = new Map(this.visitCounts);
        copy._turnIndices = new Map(this.turnIndices);
        copy._currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    get jsonToken() {
        let obj = {};
        let choiceThreads;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException('c.threadAtGeneration');
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) == null) {
                if (choiceThreads == null)
                    choiceThreads = new Map();
                choiceThreads[c.originalThreadIndex.toString()] = c.threadAtGeneration.jsonToken;
            }
        }
        if (choiceThreads != null)
            obj['choiceThreads'] = choiceThreads;
        obj['callstackThreads'] = this.callStack.GetJsonToken();
        obj['variablesState'] = this.variablesState.jsonToken;
        obj['evalStack'] = JsonSerialisation_1.JsonSerialisation.ListToJArray(this.evaluationStack);
        obj['outputStream'] = JsonSerialisation_1.JsonSerialisation.ListToJArray(this._outputStream);
        obj['currentChoices'] = JsonSerialisation_1.JsonSerialisation.ListToJArray(this._currentChoices);
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException('this.divertedPointer.path');
            }
            obj['currentDivertTarget'] = this.divertedPointer.path.componentsString;
        }
        obj['visitCounts'] = JsonSerialisation_1.JsonSerialisation.IntDictionaryToJObject(this.visitCounts);
        obj['turnIndices'] = JsonSerialisation_1.JsonSerialisation.IntDictionaryToJObject(this.turnIndices);
        obj['turnIdx'] = this.currentTurnIndex;
        obj['storySeed'] = this.storySeed;
        obj['previousRandom'] = this.previousRandom;
        obj['inkSaveVersion'] = this.kInkSaveStateVersion;
        // Not using this right now, but could do in future.
        obj['inkFormatVersion'] = this.story.inkVersionCurrent;
        return obj;
    }
    set jsonToken(value) {
        let jObject = value;
        let jSaveVersion = jObject['inkSaveVersion'];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" + jSaveVersion + "', but minimum is " + this.kMinCompatibleLoadVersion + "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject['callstackThreads'], this.story);
        this.variablesState.jsonToken = jObject['variablesState'];
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject['evalStack']);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject['outputStream']);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject['currentChoices']);
        let currentDivertTargetPath = jObject['currentDivertTarget'];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject['visitCounts']);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject['turnIndices']);
        this._currentTurnIndex = parseInt(jObject['turnIdx']);
        this.storySeed = parseInt(jObject['storySeed']);
        this.previousRandom = parseInt(jObject['previousRandom']);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject['choiceThreads'];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException('single.value');
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == '\n') {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == ' ' || c == '\t')
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == '\n') {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == ' ' || c == '\t')
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue('\n'));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue('\n'));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = (str.length - tailLastNewlineIdx) - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = (o instanceof ControlCommand_1.ControlCommand) ? o : null;
                let g = (o instanceof Glue_1.Glue) ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null && c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException('obj');
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand && cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException('rawList');
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException('StoryState.story.listDefinitions');
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException('StoryState def.result');
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException('obj');
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === 'undefined') {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error('trying to pop too many objects');
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement.functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex)
            this._currentTurnIndex++;
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === 'number' || typeof args[i] === 'string')) {
                    throw new Error('ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string');
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type != PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException('Expected external function evaluation to be complete. Stack trace: ' + this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement.evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map