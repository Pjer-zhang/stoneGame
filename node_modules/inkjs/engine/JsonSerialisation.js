"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = require("./Container");
const Value_1 = require("./Value");
const Glue_1 = require("./Glue");
const ControlCommand_1 = require("./ControlCommand");
const PushPop_1 = require("./PushPop");
const Divert_1 = require("./Divert");
const ChoicePoint_1 = require("./ChoicePoint");
const VariableReference_1 = require("./VariableReference");
const VariableAssignment_1 = require("./VariableAssignment");
const NativeFunctionCall_1 = require("./NativeFunctionCall");
const Void_1 = require("./Void");
const Tag_1 = require("./Tag");
const Path_1 = require("./Path");
const Choice_1 = require("./Choice");
const ListDefinition_1 = require("./ListDefinition");
const ListDefinitionsOrigin_1 = require("./ListDefinitionsOrigin");
const InkList_1 = require("./InkList");
const Object_1 = require("./Object");
const TypeAssertion_1 = require("./TypeAssertion");
const NullException_1 = require("./NullException");
// tslint:disable no-conditional-assignment
class JsonSerialisation {
    static ListToJArray(serialisables) {
        let jArray = [];
        for (let s of serialisables) {
            jArray.push(this.RuntimeObjectToJToken(s));
        }
        return jArray;
    }
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException('runtimeObj');
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static DictionaryRuntimeObjsToJObject(dictionary) {
        let jsonObj = {};
        for (let [key, value] of dictionary) {
            let runtimeObj = TypeAssertion_1.asOrNull(value, Object_1.InkObject);
            if (runtimeObj != null)
                jsonObj[key] = this.RuntimeObjectToJToken(runtimeObj);
        }
        return jsonObj;
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException('inkObject');
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static IntDictionaryToJObject(dict) {
        let jObj = {};
        for (let [key, value] of dict) {
            jObj[key] = TypeAssertion_1.asNumberOrThrows(value);
        }
        return jObj;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === 'number' && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === 'string') {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == '^')
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == '\n' && str.length == 1)
                return new Value_1.StringValue('\n');
            // Glue
            if (str == '<>')
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == 'L^')
                str = '^';
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == '->->')
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == '~ret')
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == 'void')
                return new Void_1.Void();
        }
        if (typeof token === 'object' && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj['^->']) {
                propValue = obj['^->'];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj['^var']) {
                propValue = obj['^var'];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ('ci' in obj) {
                    propValue = obj['ci'];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if (propValue = obj['->']) {
                isDivert = true;
            }
            else if (propValue = obj['f()']) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if (propValue = obj['->t->']) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if (propValue = obj['x()']) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if (propValue = obj['var'])
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj['c'];
                if (external) {
                    if (propValue = obj['exArgs'])
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if (propValue = obj['*']) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if (propValue = obj['flg'])
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if (propValue = obj['VAR?']) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if (propValue = obj['CNT?']) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if (propValue = obj['VAR=']) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if (propValue = obj['temp=']) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj['re'];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj['#'] !== undefined) {
                propValue = obj['#'];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if (propValue = obj['list']) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if (propValue = obj['origins']) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj['originalChoicePath'] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error('Failed to convert token to runtime object: ' + JSON.stringify(token));
    }
    static RuntimeObjectToJToken(obj) {
        // var container = obj as Container;
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            return this.ContainerToJArray(container);
        }
        // var divert = obj as Divert;
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = '->';
            if (divert.isExternal)
                divTypeKey = 'x()';
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function)
                    divTypeKey = 'f()';
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel)
                    divTypeKey = '->t->';
            }
            let targetStr;
            if (divert.hasVariableTarget)
                targetStr = divert.variableDivertName;
            else
                targetStr = divert.targetPathString;
            let jObj = {};
            jObj[divTypeKey] = targetStr;
            if (divert.hasVariableTarget)
                jObj['var'] = true;
            if (divert.isConditional)
                jObj['c'] = true;
            if (divert.externalArgs > 0)
                jObj['exArgs'] = divert.externalArgs;
            return jObj;
        }
        // var choicePoint = obj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let jObj = {};
            jObj['*'] = choicePoint.pathStringOnChoice;
            jObj['flg'] = choicePoint.flags;
            return jObj;
        }
        // var intVal = obj as IntValue;
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal)
            return intVal.value;
        // var floatVal = obj as FloatValue;
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal)
            return floatVal.value;
        // var strVal = obj as StringValue;
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline)
                return '\n';
            else
                return '^' + strVal.value;
        }
        // var listVal = obj as ListValue;
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            return this.InkListToJObject(listVal);
        }
        // var divTargetVal = obj as DivertTargetValue;
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            let divTargetJsonObj = {};
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException('divTargetVal.value');
            }
            divTargetJsonObj['^->'] = divTargetVal.value.componentsString;
            return divTargetJsonObj;
        }
        // var varPtrVal = obj as VariablePointerValue;
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            let varPtrJsonObj = {};
            varPtrJsonObj['^var'] = varPtrVal.value;
            varPtrJsonObj['ci'] = varPtrVal.contextIndex;
            return varPtrJsonObj;
        }
        // var glue = obj as Runtime.Glue;
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue)
            return '<>';
        // var controlCmd = obj as ControlCommand;
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            return JsonSerialisation._controlCommandNames[controlCmd.commandType];
        }
        // var nativeFunc = obj as Runtime.NativeFunctionCall;
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == '^')
                name = 'L^';
            return name;
        }
        // Variable reference
        // var varRef = obj as VariableReference;
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            let jObj = {};
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                jObj['CNT?'] = readCountPath;
            }
            else {
                jObj['VAR?'] = varRef.name;
            }
            return jObj;
        }
        // Variable assignment
        // var varAss = obj as VariableAssignment;
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            let key = varAss.isGlobal ? 'VAR=' : 'temp=';
            let jObj = {};
            jObj[key] = varAss.variableName;
            // Reassignment?
            if (!varAss.isNewDeclaration)
                jObj['re'] = true;
            return jObj;
        }
        // var voidObj = obj as Void;
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj)
            return 'void';
        // var tag = obj as Tag;
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            let jObj = {};
            jObj['#'] = tag.text;
            return jObj;
        }
        // Used when serialising save state only
        // var choice = obj as Choice;
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice)
            return this.ChoiceToJObject(choice);
        throw new Error('Failed to convert runtime object to Json token: ' + obj);
    }
    static ContainerToJArray(container) {
        let jArray = this.ListToJArray(container.content);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        if (namedOnlyContent != null && namedOnlyContent.size > 0 || countFlags > 0 || container.name != null) {
            let terminatingObj;
            if (namedOnlyContent != null) {
                terminatingObj = this.DictionaryRuntimeObjsToJObject(namedOnlyContent);
                for (let key in terminatingObj) {
                    if (terminatingObj.hasOwnProperty(key)) {
                        // var subContainerJArray = namedContentObj.Value as JArray;
                        let subContainerJArray = terminatingObj[key];
                        if (subContainerJArray != null) {
                            // var attrJObj = subContainerJArray [subContainerJArray.Count - 1] as JObject;
                            let attrJObj = subContainerJArray[subContainerJArray.length - 1];
                            if (attrJObj != null) {
                                delete attrJObj['#n'];
                                if (Object.keys(attrJObj).length == 0)
                                    subContainerJArray[subContainerJArray.length - 1] = null;
                            }
                        }
                    }
                }
            }
            else
                terminatingObj = {};
            if (countFlags > 0)
                terminatingObj['#f'] = countFlags;
            if (container.name != null)
                terminatingObj['#n'] = container.name;
            jArray.push(terminatingObj);
        }
        // Add null terminator to indicate that there's no dictionary
        else {
            jArray.push(null);
        }
        return jArray;
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == '#f') {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == '#n') {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj['text'].toString();
        choice.index = parseInt(jObj['index']);
        choice.sourcePath = jObj['originalChoicePath'].toString();
        choice.originalThreadIndex = parseInt(jObj['originalThreadIndex']);
        choice.pathStringOnChoice = jObj['targetPath'].toString();
        return choice;
    }
    static ChoiceToJObject(choice) {
        let jObj = {};
        jObj['text'] = choice.text;
        jObj['index'] = choice.index;
        jObj['originalChoicePath'] = choice.sourcePath;
        jObj['originalThreadIndex'] = choice.originalThreadIndex;
        jObj['targetPath'] = choice.pathStringOnChoice;
        return jObj;
    }
    static InkListToJObject(listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException('rawList');
        }
        let dict = {};
        let content = {};
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            content[item.toString()] = val;
        }
        dict['list'] = content;
        if (rawList.Count == 0 && rawList.originNames != null && rawList.originNames.length > 0) {
            // dict["origins"] = rawList.originNames.Cast<object> ().ToList ();
            dict['origins'] = rawList.originNames;
        }
        return dict;
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException('item.itemName');
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = 'ev';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = 'out';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = '/ev';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = 'du';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = 'pop';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = '~ret';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = '->->';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = 'str';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = '/str';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = 'nop';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = 'choiceCnt';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = 'turn';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = 'turns';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = 'readc';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = 'rnd';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = 'srnd';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = 'visit';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] = 'seq';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = 'thread';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = 'done';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = 'end';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = 'listInt';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = 'range';
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = 'lrnd';
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error('Control command not accounted for in serialisation');
    }
    return _controlCommandNames;
})();
exports.JsonSerialisation = JsonSerialisation;
//# sourceMappingURL=JsonSerialisation.js.map