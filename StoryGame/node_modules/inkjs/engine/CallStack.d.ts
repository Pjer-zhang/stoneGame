import { PushPopType } from './PushPop';
import { Story } from './Story';
import { Pointer } from './Pointer';
import { InkObject } from './Object';
export declare class CallStack {
    readonly elements: CallStack.Element[];
    readonly depth: number;
    readonly currentElement: CallStack.Element;
    readonly currentElementIndex: number;
    currentThread: CallStack.Thread;
    readonly canPop: boolean;
    constructor(storyContext: Story);
    constructor(toCopy: CallStack);
    Reset(): void;
    SetJsonToken(jObject: any, storyContext: Story): void;
    GetJsonToken(): any;
    PushThread(): void;
    ForkThread(): CallStack.Thread;
    PopThread(): void;
    readonly canPopThread: boolean;
    readonly elementIsEvaluateFromGame: boolean;
    Push(type: PushPopType, externalEvaluationStackHeight?: number, outputStreamLengthWithPushed?: number): void;
    CanPop(type?: PushPopType | null): boolean;
    Pop(type?: PushPopType | null): void;
    GetTemporaryVariableWithName(name: string | null, contextIndex?: number): InkObject | null;
    SetTemporaryVariable(name: string, value: any, declareNew: boolean, contextIndex?: number): void;
    ContextForVariableNamed(name: string): number;
    ThreadWithIndex(index: number): CallStack.Thread;
    readonly callStack: CallStack.Element[];
    readonly callStackTrace: string;
    _threads: CallStack.Thread[];
    _threadCounter: number;
    _startOfRoot: Pointer;
}
export declare namespace CallStack {
    class Element {
        currentPointer: Pointer;
        inExpressionEvaluation: boolean;
        temporaryVariables: Map<string, InkObject>;
        type: PushPopType;
        evaluationStackHeightWhenPushed: number;
        functionStartInOutputStream: number;
        constructor(type: PushPopType, pointer: Pointer, inExpressionEvaluation?: boolean);
        Copy(): Element;
    }
    class Thread {
        callstack: Element[];
        threadIndex: number;
        previousPointer: Pointer;
        constructor();
        constructor(jThreadObj: any, storyContext: Story);
        Copy(): Thread;
        readonly jsonToken: any;
    }
}
