"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable ban-types
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === 'number') {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === 'undefined') {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map